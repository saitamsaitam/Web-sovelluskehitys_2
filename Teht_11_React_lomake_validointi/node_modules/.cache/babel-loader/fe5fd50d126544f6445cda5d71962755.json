{"ast":null,"code":"import { useEffect, useState } from \"react\";\nimport axios from \"axios\";\n\nfunction useFetch(url) {\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState(false); // holds the data that is still loading\n\n  const [error, setError] = useState(null); // holds any errors that occur during our request\n\n  /*\r\n  \t1. if the request succeeded it sets the data to the data that was returned from the api request\r\n  \t2. if there was an error it will be cached inside of setError and we will set the error to be\r\n  \t   equal to the error state\r\n  \t3. we want to set loading to false regardless of if it succeeded or if there was any errors\r\n  \t   which you can do with finally()\r\n  \r\n  */\n\n  useEffect(() => {\n    setLoading(true);\n    axios.get(url).then(response => {\n      setData(response.data);\n    }).catch(err => {\n      setError(err);\n    }).finally(() => {\n      setLoading(false);\n    });\n    /*\r\n    useEffect needs a dependency array and the only dependency that we're going to put here is the url\r\n    because if the url changes then we want to request the new data\r\n     */\n  }, [url]);\n\n  const refetch = () => {\n    setLoading(true);\n    axios.get(url).then(response => {\n      setData(response.data);\n    }).catch(err => {\n      setError(err);\n    }).finally(() => {\n      setLoading(false);\n    });\n  };\n\n  return {\n    data,\n    loading,\n    error,\n    refetch\n  };\n}\n\nexport default useFetch;","map":{"version":3,"sources":["D:/Metropolia_koulujuttuja/KolmasVuos/Kevat/Git/Web-sovelluskehitys_2/Teht_11/src/useFetch.js"],"names":["useEffect","useState","axios","useFetch","url","data","setData","loading","setLoading","error","setError","get","then","response","catch","err","finally","refetch"],"mappings":"AAGA,SAASA,SAAT,EAAoBC,QAApB,QAAoC,OAApC;AACA,OAAOC,KAAP,MAAkB,OAAlB;;AAEA,SAASC,QAAT,CAAkBC,GAAlB,EAAuB;AACrB,QAAM,CAACC,IAAD,EAAOC,OAAP,IAAkBL,QAAQ,CAAC,EAAD,CAAhC;AACA,QAAM,CAACM,OAAD,EAAUC,UAAV,IAAwBP,QAAQ,CAAC,KAAD,CAAtC,CAFqB,CAE0B;;AAC/C,QAAM,CAACQ,KAAD,EAAQC,QAAR,IAAoBT,QAAQ,CAAC,IAAD,CAAlC,CAHqB,CAGqB;;AAE5C;;;;;;;;;AAQED,EAAAA,SAAS,CAAC,MAAM;AACdQ,IAAAA,UAAU,CAAC,IAAD,CAAV;AACAN,IAAAA,KAAK,CACFS,GADH,CACOP,GADP,EAEGQ,IAFH,CAESC,QAAD,IAAc;AAClBP,MAAAA,OAAO,CAACO,QAAQ,CAACR,IAAV,CAAP;AACD,KAJH,EAKGS,KALH,CAKUC,GAAD,IAAS;AACdL,MAAAA,QAAQ,CAACK,GAAD,CAAR;AACD,KAPH,EAOKC,OAPL,CAOa,MAAM;AACrBR,MAAAA,UAAU,CAAC,KAAD,CAAV;AACE,KATA;AAUD;;;;AAIA,GAhBQ,EAgBN,CAACJ,GAAD,CAhBM,CAAT;;AAmBA,QAAMa,OAAO,GAAG,MAAM;AACvBT,IAAAA,UAAU,CAAC,IAAD,CAAV;AACGN,IAAAA,KAAK,CACFS,GADH,CACOP,GADP,EAEGQ,IAFH,CAESC,QAAD,IAAc;AAClBP,MAAAA,OAAO,CAACO,QAAQ,CAACR,IAAV,CAAP;AACD,KAJH,EAKGS,KALH,CAKUC,GAAD,IAAS;AACdL,MAAAA,QAAQ,CAACK,GAAD,CAAR;AACD,KAPH,EAOKC,OAPL,CAOa,MAAM;AACrBR,MAAAA,UAAU,CAAC,KAAD,CAAV;AACE,KATA;AAUD,GAZD;;AAcA,SAAO;AAAEH,IAAAA,IAAF;AAAQE,IAAAA,OAAR;AAAiBE,IAAAA,KAAjB;AAAwBQ,IAAAA;AAAxB,GAAP;AACD;;AAED,eAAed,QAAf","sourcesContent":["\r\n\r\n\r\nimport { useEffect, useState } from \"react\";\r\nimport axios from \"axios\";\r\n\r\nfunction useFetch(url) {\r\n  const [data, setData] = useState([]); \r\n  const [loading, setLoading] = useState(false); // holds the data that is still loading\r\n  const [error, setError] = useState(null); // holds any errors that occur during our request\r\n\r\n/*\r\n\t1. if the request succeeded it sets the data to the data that was returned from the api request\r\n\t2. if there was an error it will be cached inside of setError and we will set the error to be\r\n\t   equal to the error state\r\n\t3. we want to set loading to false regardless of if it succeeded or if there was any errors\r\n\t   which you can do with finally()\r\n\r\n*/\r\n  useEffect(() => {\r\n    setLoading(true);\r\n    axios\r\n      .get(url)\r\n      .then((response) => {\r\n        setData(response.data);\r\n      })\r\n      .catch((err) => {\r\n        setError(err);\r\n      }).finally(() => {\r\n\t\tsetLoading(false);\r\n\t  });\r\n\t  /*\r\n\t  useEffect needs a dependency array and the only dependency that we're going to put here is the url\r\n\t  because if the url changes then we want to request the new data\r\n\t   */\r\n  }, [url]);\r\n\r\n\r\n  const refetch = () => {\r\n\tsetLoading(true);\r\n    axios\r\n      .get(url)\r\n      .then((response) => {\r\n        setData(response.data);\r\n      })\r\n      .catch((err) => {\r\n        setError(err);\r\n      }).finally(() => {\r\n\t\tsetLoading(false);\r\n\t  });\r\n  };\r\n\r\n  return { data, loading, error, refetch }\r\n}\r\n\r\nexport default useFetch;\r\n"]},"metadata":{},"sourceType":"module"}